[
  {
    "name": "Bogdanp/elm-combine",
    "version": "2.2.1",
    "docs": [
      {
        "name": "Combine.Num",
        "comment": " This module contains Parsers specific to parsing numbers.\n\n# Parsers\n@docs sign, digit, int, float\n",
        "aliases": [],
        "types": [],
        "values": [
          {
            "name": "digit",
            "comment": " Parse a digit. ",
            "type": "Combine.Parser Int"
          },
          {
            "name": "float",
            "comment": " Parse a float. ",
            "type": "Combine.Parser Float"
          },
          {
            "name": "int",
            "comment": " Parse an integer. ",
            "type": "Combine.Parser Int"
          },
          {
            "name": "sign",
            "comment": " Parse a numeric sign, returning `1` for positive numbers and `-1`\nfor negative numbers. ",
            "type": "Combine.Parser Int"
          }
        ],
        "generated-with-elm-version": "0.17.0"
      },
      {
        "name": "Combine.Char",
        "comment": " This module contains `Char`-specific Parsers.\n\n# Parsers\n@docs satisfy, char, anyChar, oneOf, noneOf, space, tab, newline, crlf, eol, lower, upper, digit, octDigit, hexDigit\n",
        "aliases": [],
        "types": [],
        "values": [
          {
            "name": "anyChar",
            "comment": " Parse any character.\n\n    parse anyChar \"a\" ==\n      (Ok 'a', { input = \"\", position = 1 })\n\n    parse anyChar \"\" ==\n      (Err [\"expected any character\"], { input = \"\", position = 0 })\n",
            "type": "Combine.Parser Char"
          },
          {
            "name": "char",
            "comment": " Parse an exact character match.\n\n    parse (char 'a') \"a\" ==\n      (Ok 'a', { input = \"\", position = 1 })\n\n    parse (char 'a') \"b\" ==\n      (Err [\"expected 'a'\"], { input = \"b\", position = 0 })\n",
            "type": "Char -> Combine.Parser Char"
          },
          {
            "name": "crlf",
            "comment": " Parse a `\\r\\n` sequence, returning a `\\n` character. ",
            "type": "Combine.Parser Char"
          },
          {
            "name": "digit",
            "comment": " Parse any base 10 digit. ",
            "type": "Combine.Parser Char"
          },
          {
            "name": "eol",
            "comment": " Parse an end of line character or sequence, returning a `\\n` character. ",
            "type": "Combine.Parser Char"
          },
          {
            "name": "hexDigit",
            "comment": " Parse any base 16 digit. ",
            "type": "Combine.Parser Char"
          },
          {
            "name": "lower",
            "comment": " Parse any lowercase character. ",
            "type": "Combine.Parser Char"
          },
          {
            "name": "newline",
            "comment": " Parse a `\\n` character. ",
            "type": "Combine.Parser Char"
          },
          {
            "name": "noneOf",
            "comment": " Parse a character that is not in the given list.\n\n    parse (noneOf ['a', 'b']) \"c\" ==\n      (Ok 'c', { input = \"\", position = 1 })\n\n    parse (noneOf ['a', 'b']) \"a\" ==\n      (Err [\"expected none of ['a','b']\"], { input = \"a\", position = 0 })\n",
            "type": "List Char -> Combine.Parser Char"
          },
          {
            "name": "octDigit",
            "comment": " Parse any base 8 digit. ",
            "type": "Combine.Parser Char"
          },
          {
            "name": "oneOf",
            "comment": " Parse a character from the given list.\n\n    parse (oneOf ['a', 'b']) \"a\" ==\n      (Ok 'a', { input = \"\", position = 1 })\n\n    parse (oneOf ['a', 'b']) \"c\" ==\n      (Err [\"expected one of ['a','b']\"], { input = \"c\", position = 0 })\n",
            "type": "List Char -> Combine.Parser Char"
          },
          {
            "name": "satisfy",
            "comment": " Parse a character matching the predicate.\n\n    parse (satisfy ((==) 'a')) \"a\" ==\n      (Ok 'a', { input = \"\", position = 1 })\n\n    parse (satisfy ((==) 'a')) \"b\" ==\n      (Err [\"could not satisfy predicate\"], { input = \"b\", position = 0 })\n",
            "type": "(Char -> Bool) -> Combine.Parser Char"
          },
          {
            "name": "space",
            "comment": " Parse a space character. ",
            "type": "Combine.Parser Char"
          },
          {
            "name": "tab",
            "comment": " Parse a `\\t` character. ",
            "type": "Combine.Parser Char"
          },
          {
            "name": "upper",
            "comment": " Parse any uppercase character. ",
            "type": "Combine.Parser Char"
          }
        ],
        "generated-with-elm-version": "0.17.0"
      },
      {
        "name": "Combine.Infix",
        "comment": " This module provides infix versions of various functions from the\n`Combine` module.\n\n# Transforming Parsers\n@docs (<$>), (<$), (<?>)\n\n# Chaining Parsers\n@docs (<*>), (*>), (<*)\n\n# Parsers\n@docs (<|>)\n",
        "aliases": [],
        "types": [],
        "values": [
          {
            "name": "*>",
            "comment": " Join two parsers, ignoring the result of the one on the left.\n\n    unprefix : Parser String\n    unprefix = string \">\" *> while ((==) ' ') *> while ((/=) ' ')\n\n    parse unprefix \"> a\" == (Ok \"a\", { input = \"\", position = 3 })\n",
            "type": "Combine.Parser x -> Combine.Parser res -> Combine.Parser res"
          },
          {
            "name": "<$",
            "comment": " Variant of `Combine.map` that ignores the Parser's result. ",
            "type": "res -> Combine.Parser x -> Combine.Parser res"
          },
          {
            "name": "<$>",
            "comment": " Synonym for `Combine.map`. ",
            "type": "(res -> res') -> Combine.Parser res -> Combine.Parser res'"
          },
          {
            "name": "<*",
            "comment": " Join two parsers, ignoring the result of the one on the right.\n\n    unsuffix : Parser String\n    unsuffix = regex \"[a-z]\" <* regex \"[!?]\"\n\n    parse unsuffix \"a!\" == (Ok \"a\", { input = \"\", position = 2 })\n",
            "type": "Combine.Parser res -> Combine.Parser x -> Combine.Parser res"
          },
          {
            "name": "<*>",
            "comment": " Synonym for `Combine.andMap`. ",
            "type": "Combine.Parser (res -> res') -> Combine.Parser res -> Combine.Parser res'"
          },
          {
            "name": "<?>",
            "comment": " Variant of `Combine.mapError` that replaces the Parser's error\nwith a List of a single string.\n\n    parse (string \"a\" <?> \"gimme an 'a'\") \"b\" ==\n      (Err [\"gimme an 'a'\"], { input = \"b\", position = 0 })\n",
            "type": "Combine.Parser res -> String -> Combine.Parser res"
          },
          {
            "name": "<|>",
            "comment": " Synonym for `or`. ",
            "type": "Combine.Parser res -> Combine.Parser res -> Combine.Parser res"
          }
        ],
        "generated-with-elm-version": "0.17.0"
      },
      {
        "name": "Combine",
        "comment": " This library provides reasonably fast parser combinators.\n\n@docs Parser, Context\n\n# Constructing Parsers\n@docs primitive\n\n# Running a Parser\n@docs parse, app, rec\n\n# Transforming Parsers\n@docs bimap, map, mapError\n\n# Chaining Parsers\n@docs andThen, andMap, sequence\n\n# Parsers\n@docs fail, succeed, string, regex, while, end, or, choice, optional, maybe, many, many1, manyTill, sepBy, sepBy1, sepEndBy, sepEndBy1, skip, skipMany, skipMany1, chainl, chainr, count, between, parens, braces, brackets\n",
        "aliases": [
          {
            "name": "Context",
            "comment": " The contex over which `Parser`s operate. ",
            "args": [],
            "type": "{ input : String, position : Int }"
          }
        ],
        "types": [
          {
            "name": "Parser",
            "comment": " The Parser type.\n\nAt their core, `Parser`s simply wrap functions from a `Context` to a\ntuple of a `Result res` and a new `Context`. ",
            "args": [
              "res"
            ],
            "cases": []
          }
        ],
        "values": [
          {
            "name": "andMap",
            "comment": " Sequence two parsers.\n\n    import Maybe\n    import Result\n    import String\n\n    num : Parser Int\n    num = (Maybe.withDefault 0 << Result.toMaybe << String.toInt) `map` regex \"[0-9]+\"\n\n    sum : Parser Int\n    sum = (+) `map` (num <* string \"+\") `andMap` num\n\n    parse sum \"1+2\" ==\n      (Ok 3, { input = \"\", position = 3 })\n",
            "type": "Combine.Parser (a -> res) -> Combine.Parser a -> Combine.Parser res"
          },
          {
            "name": "andThen",
            "comment": " Sequence two parsers, passing the result of the first parser to a\nfunction that returns the second parser. The value of the second\nparser is returned on success.\n\n    import Combine.Num exposing (int)\n\n    choosy : Parser String\n    choosy =\n      int\n        `andThen` \\x -> if x % 2 == 0\n                        then string \" is even\"\n                        else string \" is odd\"\n\n    parse choosy \"1 is odd\" ==\n      (Ok \" is odd\", { input = \"\", position = 8 })\n\n    parse choosy \"1 is even\" ==\n      (Err [\"expected \\\" is odd\\\"\"], { input = \" is even\", position = 1 })\n",
            "type": "Combine.Parser res -> (res -> Combine.Parser res') -> Combine.Parser res'"
          },
          {
            "name": "app",
            "comment": " Unwrap a parser so it can be applied to a context. ",
            "type": "Combine.Parser res -> Combine.Context -> ( Combine.Result res, Combine.Context )"
          },
          {
            "name": "between",
            "comment": " Parse something between two other parsers.\n\nThe parser\n\n    between (string \"(\") (string \")\") (string \"a\")\n\nis equivalent to the parser\n\n    string \"(\" *> string \"a\" <* string \")\"\n",
            "type": "Combine.Parser left -> Combine.Parser right -> Combine.Parser res -> Combine.Parser res"
          },
          {
            "name": "bimap",
            "comment": " Transform both the result and error message of a parser. ",
            "type": "(res -> res') -> (List String -> List String) -> Combine.Parser res -> Combine.Parser res'"
          },
          {
            "name": "braces",
            "comment": " Parse something between braces `{}`. ",
            "type": "Combine.Parser res -> Combine.Parser res"
          },
          {
            "name": "brackets",
            "comment": " Parse something between square brackets `[]`. ",
            "type": "Combine.Parser res -> Combine.Parser res"
          },
          {
            "name": "chainl",
            "comment": " Parse one or more occurences of `p` separated by `op`, recursively\napply all functions returned by `op` to the values returned by `p`. See\nthe `examples/Calc.elm` file for an example.\n",
            "type": "Combine.Parser res -> Combine.Parser (res -> res -> res) -> Combine.Parser res"
          },
          {
            "name": "chainr",
            "comment": " Similar to `chainl` but functions of `op` are applied in\nright-associative order to the values of `p`. ",
            "type": "Combine.Parser res -> Combine.Parser (res -> res -> res) -> Combine.Parser res"
          },
          {
            "name": "choice",
            "comment": " Choose between a list of parsers.\n\n    parse (choice [string \"a\", string \"b\"]) \"a\" ==\n      (Ok \"a\", { input = \"\", position = 1 })\n\n    parse (choice [string \"a\", string \"b\"]) \"b\" ==\n      (Ok \"b\", { input = \"\", position = 1 })\n",
            "type": "List (Combine.Parser res) -> Combine.Parser res"
          },
          {
            "name": "count",
            "comment": " Parse `n` occurences of `p`. ",
            "type": "Int -> Combine.Parser res -> Combine.Parser (List res)"
          },
          {
            "name": "end",
            "comment": " Fail when the input is not empty.\n\n    parse end \"\" == (Ok (), { input = \"\", position = 0 })\n    parse end \"a\" == (Err [\"expected end of input\"], { input = \"a\", position = 0 })\n",
            "type": "Combine.Parser ()"
          },
          {
            "name": "fail",
            "comment": " Fail without consuming any input. ",
            "type": "List String -> Combine.Parser res"
          },
          {
            "name": "many",
            "comment": " Apply a parser until it fails and return a list of the results.\n\n    parse (many (string \"a\")) \"aaab\" ==\n      (Ok [\"a\", \"a\", \"a\"], { input = \"b\", position = 3 })\n\n    parse (many (string \"a\")) \"\" ==\n      (Ok [], { input = \"\", position = 0 })\n",
            "type": "Combine.Parser res -> Combine.Parser (List res)"
          },
          {
            "name": "many1",
            "comment": " Parse at least one result.\n\n    parse (many1 (string \"a\")) \"a\" ==\n      (Ok [\"a\"], { input = \"\", position = 1 })\n\n    parse (many1 (string \"a\")) \"\" ==\n      (Err [\"expected \\\"a\\\"\"], { input = \"\", position = 0 })\n",
            "type": "Combine.Parser res -> Combine.Parser (List res)"
          },
          {
            "name": "manyTill",
            "comment": " Apply parser `p` zero or more times until parser `end`\nsucceeds. On success, the list of `p`'s results is returned.\n\n    string \"<!--\" *> manyTill anyChar (string \"-->\")\n",
            "type": "Combine.Parser res -> Combine.Parser end -> Combine.Parser (List res)"
          },
          {
            "name": "map",
            "comment": " Transform the result of a parser.\n\n    parse (map String.toUpper (string \"a\")) \"a\" ==\n      (Ok \"A\", { input = \"\", position = 1 })\n",
            "type": "(res -> res') -> Combine.Parser res -> Combine.Parser res'"
          },
          {
            "name": "mapError",
            "comment": " Transform the error of a parser.\n\n    parse (mapError (\\_ -> [\"bad input\"]) (string \"a\")) \"b\" ==\n      (Err [\"bad input\"], { input = \"b\", position = 0 })\n",
            "type": "(List String -> List String) -> Combine.Parser res -> Combine.Parser res"
          },
          {
            "name": "maybe",
            "comment": " Wrap the return value into a `Maybe`. Returns `Nothing` on failure.\n\n    parse (maybe (string \"a\")) \"a\" ==\n      (Ok (Just \"a\"), { input = \"\", position = 1 })\n\n    parse (maybe (string \"a\")) \"b\" ==\n      (Ok Nothing, { input = \"b\", position = 0 })\n",
            "type": "Combine.Parser res -> Combine.Parser (Maybe.Maybe res)"
          },
          {
            "name": "optional",
            "comment": " Return a default value when the given parser fails.\n\n    letterA : Parser String\n    letterA = optional \"a\" (string \"a\")\n\n    parse letterA \"a\" == (Ok \"a\", { input = \"\", position = 1 })\n    parse letterA \"b\" == (Ok \"a\", { input = \"b\", position = 0 })\n",
            "type": "res -> Combine.Parser res -> Combine.Parser res"
          },
          {
            "name": "or",
            "comment": " Choose between two parsers.\n\n    parse (string \"a\" `or` string \"b\") \"a\" ==\n      (Ok \"a\", { input = \"\", position = 1 })\n\n    parse (string \"a\" `or` string \"b\") \"b\" ==\n      (Ok \"b\", { input = \"\", position = 1 })\n\n    parse (string \"a\" `or` string \"b\") \"c\" ==\n      (Err [\"expected \\\"a\\\"\", \"expected \\\"b\\\"\"], { input = \"c\", position = 0 })\n",
            "type": "Combine.Parser res -> Combine.Parser res -> Combine.Parser res"
          },
          {
            "name": "parens",
            "comment": " Parse something between parentheses. ",
            "type": "Combine.Parser res -> Combine.Parser res"
          },
          {
            "name": "parse",
            "comment": " Parse a string.\n\n    import Combine.Num exposing (int)\n\n    parse int \"123\" ==\n      (Ok 123, { input = \"\", position = 3 })\n\n    parse int \"abc\" ==\n      (Err [\"expected an integer\"], { input = \"abc\", position = 0 })\n ",
            "type": "Combine.Parser res -> String -> ( Combine.Result res, Combine.Context )"
          },
          {
            "name": "primitive",
            "comment": " Construct a new primitive Parser.\n\nIf you find yourself reaching for this function often consider opening\na [Github issue](https://github.com/Bogdanp/elm-combine/issues) with\nthe library to have your custom Parsers included in the standard\ndistribution. ",
            "type": "(Combine.Context -> ( Combine.Result res, Combine.Context )) -> Combine.Parser res"
          },
          {
            "name": "rec",
            "comment": " Defer a parser's evaluation.\n\n    type E = ETerm String | EList (List E)\n\n    whitespace : Parser String\n    whitespace = regex \"[ \\t\\r\\n]*\"\n\n    term : Parser E\n    term = ETerm `map` (whitespace *> regex \"[a-zA-Z]+\" <* whitespace)\n\n    list : Parser E\n    list = rec (\\() -> EList `map` (string \"(\" *> many (term `or` list) <* string \")\"))\n\n    parse list \"\" ==\n      (Err [\"expected \\\"(\\\"\"], { input = \"\", position = 0 })\n\n    parse list \"()\" ==\n      (Ok (EList []), { input = \"\", position = 2 })\n\n    parse list \"(a (b c))\" ==\n      (Ok (EList [ETerm \"a\", EList [ETerm \"b\", ETerm \"c\"]]), { input = \"\", position = 9 })\n",
            "type": "(() -> Combine.Parser res) -> Combine.Parser res"
          },
          {
            "name": "regex",
            "comment": " Parse a Regex match.\n\nRegular expressions must match from the beginning of the input and their\nsubgroups are ignored. A `^` is added implicitly to the beginning of\nevery pattern unless one already exists.\n\n    parse (regex \"a+\") \"aaaaab\" ==\n      (Ok \"aaaaa\", { input = \"b\", position = 5 })\n",
            "type": "String -> Combine.Parser String"
          },
          {
            "name": "sepBy",
            "comment": " Parser zero or more occurences of one parser separated by another.\n\n    parse (sepBy (string \",\") (string \"a\")) \"b\" ==\n      (Ok [], { input = \"b\", position = 0 })\n\n    parse (sepBy (string \",\") (string \"a\")) \"a,a,a\" ==\n      (Ok [\"a\", \"a\", \"a\"], { input = \"\", position = 5 })\n\n    parse (sepBy (string \",\") (string \"a\")) \"a,a,b\" ==\n      (Ok [\"a\", \"a\"], { input = \",b\", position = 3 })\n",
            "type": "Combine.Parser x -> Combine.Parser res -> Combine.Parser (List res)"
          },
          {
            "name": "sepBy1",
            "comment": " Parse one or more occurences of one parser separated by another. ",
            "type": "Combine.Parser x -> Combine.Parser res -> Combine.Parser (List res)"
          },
          {
            "name": "sepEndBy",
            "comment": " Parse zero or more occurences of one parser separated and\noptionally ended by another.\n\n    parse (sepEndBy (string \",\") (string \"a\")) \"a,a,a,\" ==\n      (Ok [\"a\", \"a\", \"a\"], { input = \"\", position = 6 })\n",
            "type": "Combine.Parser x -> Combine.Parser res -> Combine.Parser (List res)"
          },
          {
            "name": "sepEndBy1",
            "comment": " Parse one or more occurences of one parser separated and\noptionally ended by another.\n\n    parse (sepEndBy1 (string \",\") (string \"a\")) \"\" ==\n      (Err [\"expected \\\"a\\\"\"], { input = \"\", position = 0 })\n\n    parse (sepEndBy1 (string \",\") (string \"a\")) \"a\" ==\n      (Ok [\"a\"], { input = \"\", position = 1 })\n\n    parse (sepEndBy1 (string \",\") (string \"a\")) \"a,\" ==\n      (Ok [\"a\"], { input = \"\", position = 2 })\n",
            "type": "Combine.Parser x -> Combine.Parser res -> Combine.Parser (List res)"
          },
          {
            "name": "sequence",
            "comment": " Run a list of parsers in sequence, accumulating the results.\n\n    parse (sequence [string \"a\", string \"b\"]) \"ab\" ==\n      (Ok [\"a\", \"b\"], { input = \"\", position = 2 })\n\n    parse (sequence [string \"a\", string \"b\"]) \"ac\" ==\n      (Err [\"expected \\\"b\\\"\", { input = \"c\", position = 1 })\n\n ",
            "type": "List (Combine.Parser res) -> Combine.Parser (List res)"
          },
          {
            "name": "skip",
            "comment": " Apply a parser and skip its result. ",
            "type": "Combine.Parser x -> Combine.Parser ()"
          },
          {
            "name": "skipMany",
            "comment": " Apply a parser and skip its result many times. ",
            "type": "Combine.Parser x -> Combine.Parser ()"
          },
          {
            "name": "skipMany1",
            "comment": " Apply a parser and skip its result at least once. ",
            "type": "Combine.Parser x -> Combine.Parser ()"
          },
          {
            "name": "string",
            "comment": " Parse an exact string match.\n\n    parse (string \"hello\") \"hello world\" ==\n      (Ok \"hello\", { input = \" world\", position = 5 })\n\n    parse (string \"hello\") \"goodbye\" ==\n      (Err [\"expected \\\"hello\\\"\"], { input = \"goodbye\", position = 0 })\n",
            "type": "String -> Combine.Parser String"
          },
          {
            "name": "succeed",
            "comment": " Return a value without consuming any input.\n\n    parse (succeed 1) \"a\" ==\n      (Ok 1, { input = \"a\", position = 0 })\n",
            "type": "res -> Combine.Parser res"
          },
          {
            "name": "while",
            "comment": " Consume input while the predicate matches.\n\n    parse (while ((/=) ' ')) \"test 123\" ==\n      (Ok \"test\", { input = \" 123\", position = 4 })\n",
            "type": "(Char -> Bool) -> Combine.Parser String"
          }
        ],
        "generated-with-elm-version": "0.17.0"
      }
    ]
  },
  {
    "name": "Bogdanp/elm-route",
    "version": "2.0.3",
    "docs": [
      {
        "name": "Route",
        "comment": " This module exposes combinators for creating route parsers.\n\n@docs Route, Router\n\n## Routing\n@docs route, (:=), router, child, match, reverse\n\n## Route combinators\n@docs prefix, (<//>), and, (</>), suffix, (<>), static, custom, string, int\n",
        "aliases": [],
        "types": [
          {
            "name": "Route",
            "comment": " Routes represent concrete parsers for paths. Routes can be combined\nand they keep track of their path components in order to provide\nautomatic reverse routing.\n ",
            "args": [
              "a"
            ],
            "cases": []
          },
          {
            "name": "Router",
            "comment": " A Router is, at its core, a List of Routes.\n\n    sitemap = router [routeA, routeB]\n\n ",
            "args": [
              "a"
            ],
            "cases": []
          }
        ],
        "values": [
          {
            "name": ":=",
            "comment": " A synonym for `route`.\n\n    type Sitemap\n      = HomeR ()\n\n    homeR : Route Sitemap\n    homeR = HomeR := static \"\"\n\n ",
            "type": "(a -> res) -> Route.Route a -> Route.Route res",
            "associativity": "left",
            "precedence": 7
          },
          {
            "name": "<//>",
            "comment": " A synonym for `prefix`.\n\n    type Sitemap\n      = UserR Int\n\n    userR = UserR := \"users\" <//> int\n    sitemap = router [userR]\n\n    > match sitemap \"/users/\"\n    Nothing : Maybe.Maybe Sitemap\n\n    > match sitemap \"/users/1\"\n    Just (UserR 1) : Maybe.Maybe Sitemap\n\n ",
            "type": "String -> Route.Route res -> Route.Route res",
            "associativity": "right",
            "precedence": 9
          },
          {
            "name": "</>",
            "comment": " A synonym for `and`.\n\n    type Sitemap\n      = AddR (Int, Int)\n\n    addR = AddR := int </> int\n    sitemap = router [addR]\n\n    > match sitemap \"/1/2\"\n    Just (AddR (1,2)) : Maybe.Maybe Sitemap\n\n ",
            "type": "Route.Route a -> Route.Route b -> Route.Route ( a, b )",
            "associativity": "left",
            "precedence": 8
          },
          {
            "name": "<>",
            "comment": " A synonym for `suffix`.\n\n    type Sitemap\n      = UserEmailsR Int\n      = UserEmailsR' (Int, ())\n\n    userEmailsR = UserEmailsR := \"users\" <//> int <> \"emails\"\n    userEmailsR' = UserEmailsR' := \"users\" <//> int </> static \"emails\"\n    sitemap = router [userEmailsR, userEmailsR']\n\n    > match sitemap \"/users/1/emails\"\n    Just (UserEmailsR 1) : Maybe.Maybe Sitemap\n\n    > match sitemap \"/users/1/emails-static\"\n    Just (UserEmailsR' (1,())) : Maybe.Maybe Sitemap\n\n ",
            "type": "Route.Route res -> String -> Route.Route res",
            "associativity": "right",
            "precedence": 9
          },
          {
            "name": "and",
            "comment": " Compose two Routes.\n\n    type Sitemap\n      = AddR (Int, Int)\n\n    addR = AddR := int `and` int\n    sitemap = router [addR]\n\n    > match sitemap \"/1/2\"\n    Just (AddR (1,2)) : Maybe.Maybe Sitemap\n\n ",
            "type": "Route.Route a -> Route.Route b -> Route.Route ( a, b )"
          },
          {
            "name": "child",
            "comment": " Routers may be nested. This function is useful in situations\nwhere you want to split your routes into multiple types while still\nmaintaining a single top-level \"site map\".\n\n    type AdminSitemap\n      = AdminHomeR ()\n      | AdminUsersR ()\n\n    adminHomeR = AdminHomeR := static \"admin\"\n    adminUsersR = AdminHomeR := \"admin\" <//> static \"users\"\n    adminSitemap = router [adminHomeR, adminUsersR]\n\n    type Sitemap\n      = HomeR ()\n      | BlogR ()\n      | AdminR AdminSitemap\n\n    homeR = HomeR := static \"\"\n    blogR = BlogR := static \"blog\"\n    sitemap = router [homeR, blogR, child AdminR adminSitemap]\n\nSee `examples/Reuse.elm` for a more advanced use case of this.\n\n ",
            "type": "(a -> b) -> Route.Router a -> Route.Route b"
          },
          {
            "name": "custom",
            "comment": " Create a Route with a custom Parser.\n\n    import Combine exposing (..)\n    import Combine.Infix exposing (..)\n\n    type Category\n      = Snippet\n      | Post\n\n    type Sitemap\n      = CategoryR Category\n\n    categoryR = CategoryR := \"categories\" <//> custom categoryParser\n    sitemap = router [categoryR]\n\n    > match sitemap \"/categories/a\"\n    Nothing : Maybe.Maybe Sitemap\n\n    > match sitemap \"/categories/Post\"\n    Just (CategoryR Post) : Maybe.Maybe Sitemap\n\n    > match sitemap \"/categories/Snippet\"\n    Just (CategoryR Snippet) : Maybe.Maybe Sitemap\n\nSee `examples/Custom.elm` for a complete example.\n\n ",
            "type": "Combine.Parser a -> Route.Route a"
          },
          {
            "name": "int",
            "comment": " A Route that matches any integer.\n\n    type Sitemap\n      = UserR Int\n\n    userR = UserR := \"users\" <//> int\n    sitemap = router [userR]\n\n    > match sitemap \"/users/a\"\n    Nothing : Maybe.Maybe Sitemap\n\n    > match sitemap \"/users/1\"\n    Just (UserR 1) : Maybe.Maybe Sitemap\n\n    > match sitemap \"/users/-1\"\n    Just (UserR -1) : Maybe.Maybe Sitemap\n\n ",
            "type": "Route.Route Int"
          },
          {
            "name": "match",
            "comment": " Given a Router and an arbitrary String representing a path, this\nfunction will return the first Route that matches that path.\n\n    type Sitemap\n      = HomeR ()\n      | UsersR ()\n      | UserR Int\n\n    homeR = HomeR := static \"\"\n    usersR = UsersR := static \"users\"\n    usersR = UserR := \"users\" <//> int\n    sitemap = router [homeR, userR, usersR]\n\n    > match siteMap \"/a\"\n    Nothing : Maybe.Maybe Sitemap\n\n    > match siteMap \"/\"\n    Just (HomeR ()) : Maybe.Maybe Sitemap\n\n    > match siteMap \"/users\"\n    Just (UsersR ()) : Maybe.Maybe Sitemap\n\n    > match siteMap \"/users/1\"\n    Just (UserR 1) : Maybe.Maybe Sitemap\n\n    > match siteMap \"/users/1\"\n    Just (UserR 1) : Maybe.Maybe Sitemap\n\n ",
            "type": "Route.Router a -> String -> Maybe.Maybe a"
          },
          {
            "name": "prefix",
            "comment": " Prefix a `Route` with a string.\n\n    type Sitemap\n      = UserR Int\n\n    userR = UserR := prefix \"users\" int\n    sitemap = router [userR]\n\n    > match sitemap \"/users/\"\n    Nothing : Maybe.Maybe Sitemap\n\n    > match sitemap \"/users/1\"\n    Just (UserR 1) : Maybe.Maybe Sitemap\n\n ",
            "type": "String -> Route.Route res -> Route.Route res"
          },
          {
            "name": "reverse",
            "comment": " Render a path given a route and a list of route components.\n\n    type Sitemap\n      = HomeR ()\n      | UsersR ()\n      | UserR Int\n\n    homeR = HomeR := static \"\"\n    usersR = UsersR := static \"users\"\n    usersR = UserR := \"users\" <//> int\n    sitemap = router [homeR, userR, usersR]\n\n    > reverse homeR []\n    \"/\"\n\n    > reverse usersR []\n    \"/users\"\n\n    > reverse userR [\"1\"]\n    \"/users/1\"\n\nIf you are willing to write some boilerplate, this function can be used\nto construct a reasonably-safe reverse routing function specific to your\napplication:\n\n    render : Sitemap -> String\n    render r =\n      case r of\n        HomeR () -> reverse homeR []\n        UsersR () -> reverse usersR []\n        UserR uid -> reverse userR [toString uid]\n\n    > render (HomeR ())\n    \"/\"\n\n    > render (UsersR ())\n    \"/users\"\n\n    > render (UserR 1)\n    \"/users/1\"\n\nThis function will crash at runtime if there is a mismatch between the\nroute and the list of arguments that is passed in. For example:\n\n    > reverse deepR []\n    Error: Ran into a `Debug.crash` in module `Route`\n\n    This was caused by the `case` expression between lines 145 and 175.\n    One of the branches ended with a crash and the following value got through:\n\n        ([],[CInt,CInt,CInt])\n\n    The message provided by the code author is:\n\n        'reverse' called with an unexpected number of arguments\n\n    > reverse deepR [\"a\"]\n    Error: Ran into a `Debug.crash` in module `Route`\n\n    This was caused by the `case` expression between lines 171 and 176.\n    One of the branches ended with a crash and the following value got through:\n\n        Err (\"could not convert string 'a' to an Int\")\n\n    The message provided by the code author is:\n\n        could not convert string 'a' to an Int in a call to 'reverse'\n\n ",
            "type": "Route.Route a -> List String -> String"
          },
          {
            "name": "route",
            "comment": " Declare a Route.\n\n    type Sitemap\n      = HomeR ()\n\n    homeR : Route Sitemap\n    homeR = route HomeR (static \"\")\n\n ",
            "type": "(a -> res) -> Route.Route a -> Route.Route res"
          },
          {
            "name": "router",
            "comment": " Construct a Router from a list of Routes.\n\n    type Sitemap\n      = HomeR ()\n      | BlogR ()\n\n    homeR = HomeR := static \"\"\n    blogR = BlogR := static \"blog\"\n    sitemap = router [homeR, blogR]\n\n ",
            "type": "List (Route.Route a) -> Route.Router a"
          },
          {
            "name": "static",
            "comment": " Create a Route that matches a static String.\n\n    type Sitemap\n      = BlogR ()\n\n    blogR = BlogR := static \"blog\"\n    sitemap = router [blogR]\n\n    > match sitemap \"/blog\"\n    Just (BlogR ()) : Maybe.Maybe Sitemap\n\n ",
            "type": "String -> Route.Route ()"
          },
          {
            "name": "string",
            "comment": " A Route that matches any string.\n\n    type Sitemap\n      = PostR String\n\n    postR = PostR := \"posts\" <//> string\n    sitemap = router [postR]\n\n    > match sitemap \"/posts/\"\n    Nothing : Maybe.Maybe Sitemap\n\n    > match sitemap \"/posts/hello-world/test\"\n    Nothing : Maybe.Maybe Sitemap\n\n    > match sitemap \"/posts/hello-world\"\n    Just (PostR \"hello-world\") : Maybe.Maybe Sitemap\n\n ",
            "type": "Route.Route String"
          },
          {
            "name": "suffix",
            "comment": " Suffix a `Route` with a string. This can be used in place\nof `static` when there are static path components at the end of a\npath.\n\n    type Sitemap\n      = UserEmailsR Int\n      = UserEmailsR' (Int, ())\n\n    userEmailsR = UserEmailsR := suffix \"emails\" (prefix \"users\" int)\n    userEmailsR' = UserEmailsR' := prefix \"users\" int `and` static \"emails-static\"\n    sitemap = router [userEmailsR, userEmailsR']\n\n    > match sitemap \"/users/1/emails\"\n    Just (UserEmailsR 1) : Maybe.Maybe Sitemap\n\n    > match sitemap \"/users/1/emails-static\"\n    Just (UserEmailsR' (1,())) : Maybe.Maybe Sitemap\n\n ",
            "type": "String -> Route.Route res -> Route.Route res"
          }
        ],
        "generated-with-elm-version": "0.17.0"
      },
      {
        "name": "Route.QueryString",
        "comment": " This module exposes functions for working with query strings.\n\nYou can manipulate query strings:\n\n    empty\n      |> add \"a\" \"hello\"\n      |> add \"a\" \"goodbye\"\n      |> add \"b\" \"1\"\n      |> render\n\nAnd you can parse and extract their parameters:\n\n    let\n      qs = parse \"?a=1&a=2&a=test&b=hello\"\n      a = many int qs\n      b = one string qs |> Maybe.withDefault \"goodbye\"\n    in\n      (a, b)\n\n## Types\n@docs QueryString\n\n## Constructing QueryStrings\n@docs parse, empty\n\n## Manipulating parameters\n@docs render, add, remove, filter\n\n## Extracting parameters\n@docs all, one, many\n\n### Parsers\n@docs string, int\n",
        "aliases": [],
        "types": [
          {
            "name": "QueryString",
            "comment": " Represents a parsed query string. ",
            "args": [],
            "cases": []
          }
        ],
        "values": [
          {
            "name": "add",
            "comment": " Add a value to a key.\n\n    > parse \"?a=1&b=a&a=c\" |> add \"a\" \"2\" |> render\n    \"?a=2&a=1&a=c&b=a\" : String\n\n    > parse \"?a=1&b=a&a=c\" |> add \"d\" \"hello\" |> render\n    \"?a=1&a=c&b=a&d=hello\" : String\n\n ",
            "type": "String -> String -> Route.QueryString.QueryString -> Route.QueryString.QueryString"
          },
          {
            "name": "all",
            "comment": " Retrieve all of the values for a given key.\n\n    > parse \"?a=1&a=2\" |> all \"a\"\n    [\"1\",\"2\"] : List String\n\n    > parse \"?a=1&a=2\" |> all \"b\"\n    [] : List String\n\n ",
            "type": "String -> Route.QueryString.QueryString -> List String"
          },
          {
            "name": "empty",
            "comment": " Construct an empty QueryString. ",
            "type": "Route.QueryString.QueryString"
          },
          {
            "name": "filter",
            "comment": " Filter a key's values.\n\n    > parse \"?a=1&b=a&a=c\" |> filter \"a\" ((==) \"1\") |> render\n    \"?a=1&b=a\" : String\n\n ",
            "type": "String -> (String -> Bool) -> Route.QueryString.QueryString -> Route.QueryString.QueryString"
          },
          {
            "name": "int",
            "comment": " A Parser that accepts any integer. ",
            "type": "Combine.Parser Int"
          },
          {
            "name": "many",
            "comment": " Retrieve zero or more values for some key. Values are funneled\nthrough the given parser before being returned.\n\n    > parse \"?a=1&a=c&a=2\" |> many int \"a\"\n    [1,2] : List Int\n\n ",
            "type": "Combine.Parser a -> String -> Route.QueryString.QueryString -> List a"
          },
          {
            "name": "one",
            "comment": " Retrieve a single value for a given key. Values are funneled through\nthe given parser before being returned.\n\n    > parse \"?a=1&a=2\" |> one string \"a\"\n    Just \"2\" : Maybe.Maybe String\n\n    > parse \"?a=1&a=2\" |> one int \"a\"\n    Just 2 : Maybe.Maybe Int\n\n    > parse \"?a=1&a=c\" |> one int \"a\"\n    Just 1 : Maybe.Maybe Int\n\n ",
            "type": "Combine.Parser a -> String -> Route.QueryString.QueryString -> Maybe.Maybe a"
          },
          {
            "name": "parse",
            "comment": " Turn a String into a QueryString. The initial `?` is optional.\n\n    > parse \"\"\n    QueryString (Dict.fromList []) : Route.QueryString.QueryString\n\n    > parse \"?a=1&b=c&a=2\"\n    QueryString (Dict.fromList [(\"a\",[\"1\",\"2\"]),(\"b\",[\"c\"])])\n        : Route.QueryString.QueryString\n\n    > parse \"a=1&b=c&a=2\"\n    QueryString (Dict.fromList [(\"a\",[\"1\",\"2\"]),(\"b\",[\"c\"])])\n        : Route.QueryString.QueryString\n\n ",
            "type": "String -> Route.QueryString.QueryString"
          },
          {
            "name": "remove",
            "comment": " Remove a key.\n\n    > parse \"?a=1&b=a&a=c\" |> remove \"a\" |> render\n    \"?b=a\" : String\n\n    > parse \"?a=1&b=a&a=c\" |> remove \"c\" |> render\n    \"?a=1&a=c&b=a\" : String\n\n ",
            "type": "String -> Route.QueryString.QueryString -> Route.QueryString.QueryString"
          },
          {
            "name": "render",
            "comment": " Render a QueryString to a String.\n\n    > parse \"?a=1&b=a&a=c\" |> render\n    \"?a=1&a=c&b=a\" : String\n\n ",
            "type": "Route.QueryString.QueryString -> String"
          },
          {
            "name": "string",
            "comment": " A Parser that accepts any string. ",
            "type": "Combine.Parser String"
          }
        ],
        "generated-with-elm-version": "0.17.0"
      }
    ]
  },
  {
    "name": "Dandandan/parser",
    "version": "6.2.5",
    "docs": [
      {
        "name": "Parser.Char",
        "comment": " Parsing characters\n\n@docs upper, lower, between, parenthesized, bracketed, braced, quoted, singleQuoted\n\n",
        "aliases": [],
        "types": [],
        "values": [
          {
            "name": "between",
            "comment": " Parse a parser between two `Chars` ",
            "type": "Char -> Char -> Parser.Parser result -> Parser.Parser result"
          },
          {
            "name": "braced",
            "comment": " Parses a parser between braces `{` and `}`",
            "type": "Parser.Parser result -> Parser.Parser result"
          },
          {
            "name": "bracketed",
            "comment": " Parses a parser between brackets `[` and `]` ",
            "type": "Parser.Parser result -> Parser.Parser result"
          },
          {
            "name": "lower",
            "comment": " Parse a lower case character ",
            "type": "Parser.Parser Char"
          },
          {
            "name": "parenthesized",
            "comment": " Parse a parser between parentheses `(` and `)`",
            "type": "Parser.Parser result -> Parser.Parser result"
          },
          {
            "name": "quoted",
            "comment": " Parses a parser between quotes `\"` and `\"`",
            "type": "Parser.Parser result -> Parser.Parser result"
          },
          {
            "name": "singleQuoted",
            "comment": " Parses a parser between quotes `'` and `'`",
            "type": "Parser.Parser result -> Parser.Parser result"
          },
          {
            "name": "upper",
            "comment": " Parse a upper case character ",
            "type": "Parser.Parser Char"
          }
        ],
        "generated-with-elm-version": "0.17.0"
      },
      {
        "name": "Parser.Number",
        "comment": " Parsing numbers\n\n@docs digit, natural, integer, float, sign\n\n",
        "aliases": [],
        "types": [],
        "values": [
          {
            "name": "digit",
            "comment": " Parse a digit ",
            "type": "Parser.Parser Int"
          },
          {
            "name": "float",
            "comment": " Parse a float with optional sign ",
            "type": "Parser.Parser Float"
          },
          {
            "name": "integer",
            "comment": " Parse an integer with optional sign ",
            "type": "Parser.Parser Int"
          },
          {
            "name": "natural",
            "comment": " Parse a natural number ",
            "type": "Parser.Parser Int"
          },
          {
            "name": "sign",
            "comment": " Parse a optional sign, succeeds with a -1 if it matches a minus `Char`, otherwise it returns 1 ",
            "type": "Parser.Parser Int"
          }
        ],
        "generated-with-elm-version": "0.17.0"
      },
      {
        "name": "Parser",
        "comment": " A simple parser combinator library.\n\n@docs Parser\n\n#Running the parser\n@docs parse, parseAll\n\n#Core functions\n@docs map, or, andMap, andThen, and\n\n#Combinators\n@docs succeed, satisfy, empty, symbol, token, choice, optional, many, some, separatedBy, end\n\n#Writing recursive grammars\n@docs recursively\n\n#Core functions (infix operators)\n@docs (<*), (*>), (<$)\n\n",
        "aliases": [],
        "types": [
          {
            "name": "Parser",
            "comment": " Parser type\n",
            "args": [
              "result"
            ],
            "cases": []
          }
        ],
        "values": [
          {
            "name": "*>",
            "comment": " Variant of `and` that ignores the result of the parser at the left ",
            "type": "Parser.Parser x -> Parser.Parser result -> Parser.Parser result"
          },
          {
            "name": "<$",
            "comment": " Variant of `map` that ignores the result of the parser ",
            "type": "result -> Parser.Parser x -> Parser.Parser result"
          },
          {
            "name": "<*",
            "comment": " Variant of `and` that ignores the result of the parser at the right ",
            "type": "Parser.Parser result -> Parser.Parser x -> Parser.Parser result"
          },
          {
            "name": "and",
            "comment": " Sequence two parsers (infix version)\n\n    type Date = Date Int Int Int\n    date = Date `map` year `and` month `and` day\n",
            "type": "Parser.Parser (result -> result2) -> Parser.Parser result -> Parser.Parser result2",
            "associativity": "left",
            "precedence": 4
          },
          {
            "name": "andMap",
            "comment": " Sequence two parsers\n\n    type Date = Date Int Int Int\n    date =\n        map Date year\n        |> andMap month\n        |> andMap day\n",
            "type": "Parser.Parser result -> Parser.Parser (result -> result2) -> Parser.Parser result2"
          },
          {
            "name": "andThen",
            "comment": " Sequence two parsers, but pass the result of the first parser to the second parser.\n    This is useful for creating context sensitive parsers like XML.\n\n    tag = openTag\n        |> andThen (tagLiteral)\n",
            "type": "Parser.Parser result -> (result -> Parser.Parser result2) -> Parser.Parser result2"
          },
          {
            "name": "choice",
            "comment": " Combine a list of parsers ",
            "type": "List (Parser.Parser result) -> Parser.Parser result"
          },
          {
            "name": "empty",
            "comment": " Parser that always fails ",
            "type": "Parser.Parser result"
          },
          {
            "name": "end",
            "comment": " Succeeds when input is empty ",
            "type": "Parser.Parser ()"
          },
          {
            "name": "many",
            "comment": " Parses zero or more occurences of a parser ",
            "type": "Parser.Parser result -> Parser.Parser (List result)"
          },
          {
            "name": "map",
            "comment": " Map a function over the result of the parser\n      -- Counts the amount of digits\n      count : Parser Int\n      count = map length (many digit)\n\n",
            "type": "(result -> result2) -> Parser.Parser result -> Parser.Parser result2",
            "associativity": "left",
            "precedence": 4
          },
          {
            "name": "optional",
            "comment": " Parses an optional element ",
            "type": "Parser.Parser result -> result -> Parser.Parser result"
          },
          {
            "name": "or",
            "comment": " Choice between two parsers\n\n      oneOrTwo = symbol '1' `or` symbol '2'\n",
            "type": "Parser.Parser result -> Parser.Parser result -> Parser.Parser result",
            "associativity": "right",
            "precedence": 3
          },
          {
            "name": "parse",
            "comment": " Parse a `String` using a parser, return first result ",
            "type": "Parser.Parser result -> String -> Result.Result String result"
          },
          {
            "name": "parseAll",
            "comment": " Parse a `String` using a parser, return list of results ",
            "type": "Parser.Parser result -> String -> Result.Result String (List result)"
          },
          {
            "name": "recursively",
            "comment": " For realizing otherwise inexpressible recursive grammars. For\nexample, while\n\n    bbbba = (symbol 'a') `or` (symbol 'b' *> bbbba)\n\nwill fail at runtime with a non-termination issue, the replacement\n\n    bbbba = (symbol 'a') `or` (symbol 'b' *> recursively (\\() -> bbbba))\n\nis safe.\n",
            "type": "(() -> Parser.Parser result) -> Parser.Parser result"
          },
          {
            "name": "satisfy",
            "comment": " Parser that satisfies a given predicate ",
            "type": "(Char -> Bool) -> Parser.Parser Char"
          },
          {
            "name": "separatedBy",
            "comment": " Parses a sequence of the first parser, separated by the second parser\n```\nnaturals = separatedBy Number.natural (symbol ',')\n```\n ",
            "type": "Parser.Parser result -> Parser.Parser result2 -> Parser.Parser (List result)"
          },
          {
            "name": "some",
            "comment": " Parses one or more occurences of a parser ",
            "type": "Parser.Parser result -> Parser.Parser (List result)"
          },
          {
            "name": "succeed",
            "comment": " Parser that always succeeds without consuming input ",
            "type": "result -> Parser.Parser result"
          },
          {
            "name": "symbol",
            "comment": " Parses a symbol ",
            "type": "Char -> Parser.Parser Char"
          },
          {
            "name": "token",
            "comment": " Parses a token of symbols ",
            "type": "String -> Parser.Parser String"
          }
        ],
        "generated-with-elm-version": "0.17.0"
      }
    ]
  },
  {
    "name": "Fresheyeball/elm-nearly-eq",
    "version": "1.1.0",
    "docs": [
      {
        "name": "Nearly",
        "comment": "\n\n@docs nearly, (~=), epsillon\n\n",
        "aliases": [],
        "types": [],
        "values": [
          {
            "name": "epsillon",
            "comment": "\nepsillon\n",
            "type": "Float"
          },
          {
            "name": "nearly",
            "comment": "\nNearly is used to curry an epsillon into a fuzzy equality.\nFor example:\n\n```\nTrue == let toThreePlaces = nearly 0.0001\n        in 0.1234588 `toThreePlaces` 0.1234565\n```\n",
            "type": "Float -> Float -> Float -> Bool"
          },
          {
            "name": "~=",
            "comment": "\nPre-baked fuzzy equality, with `1.0e-5` as epsillon.\n```\n(~=) = nearly 1.0e-5\n```\n",
            "type": "Float -> Float -> Bool",
            "associativity": "right",
            "precedence": 6
          }
        ],
        "generated-with-elm-version": "0.17.0"
      }
    ]
  },
  {
    "name": "Fresheyeball/elm-number-expanded",
    "version": "1.0.1",
    "docs": [
      {
        "name": "Number.Expanded",
        "comment": "\nExpanded Numbers\nA number that can either be finite or infinite\n\n@docs Expanded, toExpanded, withDefault, withDefaults, map\n",
        "aliases": [],
        "types": [
          {
            "name": "Expanded",
            "comment": " Expanded number can be Positive or Negative Infinity\n",
            "args": [
              "number"
            ],
            "cases": [
              [
                "Finite",
                [
                  "number"
                ]
              ],
              [
                "PosInfinity",
                []
              ],
              [
                "NegInfinity",
                []
              ]
            ]
          }
        ],
        "values": [
          {
            "name": "map",
            "comment": "\nNot a Functor, but still mappable\n",
            "type": "(number -> number) -> Number.Expanded.Expanded number -> Number.Expanded.Expanded number"
          },
          {
            "name": "toExpanded",
            "comment": " ",
            "type": "number -> Number.Expanded.Expanded number"
          },
          {
            "name": "withDefault",
            "comment": "\nGet the value out of `Expanded` providing a default for the infinite case\n",
            "type": "a -> (number -> a) -> Number.Expanded.Expanded number -> a"
          },
          {
            "name": "withDefaults",
            "comment": "\nGet the value out of `Expanded` providing a default for the infinite cases.\nFirst argument is the default for the `PosInfinity` case, the second is for `NegInfinity`\n",
            "type": "a -> a -> (number -> a) -> Number.Expanded.Expanded number -> a"
          }
        ],
        "generated-with-elm-version": "0.17.0"
      }
    ]
  },
  {
    "name": "Fresheyeball/elm-restrict-number",
    "version": "1.0.1",
    "docs": [
      {
        "name": "NonZero",
        "comment": "\nNonZero numbers are numbers excluding zero.\nBecause the constructor for `NonZero` is not exported, you can be\nconfident that if you are using a `NonZero`, then its `NonZero`.\n\n@docs NonZero, fromNum, toNum\n",
        "aliases": [],
        "types": [
          {
            "name": "NonZero",
            "comment": " ",
            "args": [
              "number"
            ],
            "cases": []
          }
        ],
        "values": [
          {
            "name": "fromNum",
            "comment": " ",
            "type": "number -> Maybe.Maybe (NonZero.NonZero number)"
          },
          {
            "name": "toNum",
            "comment": " ",
            "type": "NonZero.NonZero number -> number"
          }
        ],
        "generated-with-elm-version": "0.17.0"
      },
      {
        "name": "Positive",
        "comment": "\nPositive numbers exclude zero.\nBecause the constructor for `Positive` is not exported, you can be\nconfident that if you are using a `Positive`, then its `Positive`.\n\n@docs Positive, fromNum, toNum\n",
        "aliases": [],
        "types": [
          {
            "name": "Positive",
            "comment": " ",
            "args": [
              "number"
            ],
            "cases": []
          }
        ],
        "values": [
          {
            "name": "fromNum",
            "comment": " ",
            "type": "number -> Maybe.Maybe (Positive.Positive number)"
          },
          {
            "name": "toNum",
            "comment": " ",
            "type": "Positive.Positive number -> number"
          }
        ],
        "generated-with-elm-version": "0.17.0"
      },
      {
        "name": "Even",
        "comment": "\nBecause the constructor for `Even` is not exported, you can be\nconfident that if you are using a `Even`, then its `Even`.\n\n@docs Even, fromInt, toInt\n",
        "aliases": [],
        "types": [
          {
            "name": "Even",
            "comment": " ",
            "args": [],
            "cases": []
          }
        ],
        "values": [
          {
            "name": "fromInt",
            "comment": " ",
            "type": "Int -> Maybe.Maybe Even.Even"
          },
          {
            "name": "toInt",
            "comment": " ",
            "type": "Even.Even -> Int"
          }
        ],
        "generated-with-elm-version": "0.17.0"
      },
      {
        "name": "Odd",
        "comment": "\nBecause the constructor for `Odd` is not exported, you can be\nconfident that if you are using a `Odd`, then its `Odd`.\n\n@docs Odd, fromInt, toInt\n",
        "aliases": [],
        "types": [
          {
            "name": "Odd",
            "comment": " ",
            "args": [],
            "cases": []
          }
        ],
        "values": [
          {
            "name": "fromInt",
            "comment": " ",
            "type": "Int -> Maybe.Maybe Odd.Odd"
          },
          {
            "name": "toInt",
            "comment": " ",
            "type": "Odd.Odd -> Int"
          }
        ],
        "generated-with-elm-version": "0.17.0"
      },
      {
        "name": "Negative",
        "comment": "\nNegative numbers exclude zero.\nBecause the constructor for `Negative` is not exported, you can be\nconfident that if you are using a `Negative`, then its `Negative`.\n\n@docs Negative, fromNum, toNum\n",
        "aliases": [],
        "types": [
          {
            "name": "Negative",
            "comment": " ",
            "args": [
              "number"
            ],
            "cases": []
          }
        ],
        "values": [
          {
            "name": "fromNum",
            "comment": " ",
            "type": "number -> Maybe.Maybe (Negative.Negative number)"
          },
          {
            "name": "toNum",
            "comment": " ",
            "type": "Negative.Negative number -> number"
          }
        ],
        "generated-with-elm-version": "0.17.0"
      },
      {
        "name": "Natural",
        "comment": "\nNatural numbers are positive whole numbers excluding zero.\nBecause the constructor for `Natural` is not exported, you can be\nconfident that if you are using a `Natural`, then its `Natural`.\n\n@docs Natural, fromInt, toInt\n",
        "aliases": [],
        "types": [
          {
            "name": "Natural",
            "comment": " ",
            "args": [],
            "cases": []
          }
        ],
        "values": [
          {
            "name": "fromInt",
            "comment": " ",
            "type": "Int -> Maybe.Maybe Natural.Natural"
          },
          {
            "name": "toInt",
            "comment": " ",
            "type": "Natural.Natural -> Int"
          }
        ],
        "generated-with-elm-version": "0.17.0"
      }
    ]
  },
  {
    "name": "Fresheyeball/elm-tuple-extra",
    "version": "2.0.1",
    "docs": [
      {
        "name": "Tuple2",
        "comment": "\n\n# Map\n@docs map, mapFst, mapSnd, mapEach, mapBoth\n\n# Swap\n@docs swap\n\n# Transform\n@docs toList\n\n",
        "aliases": [],
        "types": [],
        "values": [
          {
            "name": "map",
            "comment": " ",
            "type": "(b -> x) -> ( a, b ) -> ( a, x )"
          },
          {
            "name": "mapBoth",
            "comment": " ",
            "type": "(a -> b) -> ( a, a ) -> ( b, b )"
          },
          {
            "name": "mapEach",
            "comment": " ",
            "type": "(a -> x) -> (b -> x') -> ( a, b ) -> ( x, x' )"
          },
          {
            "name": "mapFst",
            "comment": " ",
            "type": "(a -> x) -> ( a, b ) -> ( x, b )"
          },
          {
            "name": "mapSnd",
            "comment": " ",
            "type": "(b -> x) -> ( a, b ) -> ( a, x )"
          },
          {
            "name": "swap",
            "comment": " ",
            "type": "( a, b ) -> ( b, a )"
          },
          {
            "name": "toList",
            "comment": " ",
            "type": "( a, a ) -> List a"
          }
        ],
        "generated-with-elm-version": "0.17.0"
      },
      {
        "name": "Tuple3",
        "comment": "\n# Getters\n@docs fst, snd, trd, tail, init\n\n# Maps\n@docs map, mapFst, mapSnd, mapTrd, mapEach, mapAll\n\n# Swap\n@docs swirlr, swirll\n\n# Transform\n@docs toList\n",
        "aliases": [],
        "types": [],
        "values": [
          {
            "name": "fst",
            "comment": " ",
            "type": "( a, b, c ) -> a"
          },
          {
            "name": "init",
            "comment": " ",
            "type": "( a, b, c ) -> ( a, b )"
          },
          {
            "name": "map",
            "comment": " ",
            "type": "(c -> x) -> ( a, b, c ) -> ( a, b, x )"
          },
          {
            "name": "mapAll",
            "comment": " ",
            "type": "(a -> b) -> ( a, a, a ) -> ( b, b, b )"
          },
          {
            "name": "mapEach",
            "comment": " ",
            "type": "(a -> x) -> (b -> x') -> (c -> x'') -> ( a, b, c ) -> ( x, x', x'' )"
          },
          {
            "name": "mapFst",
            "comment": " ",
            "type": "(a -> x) -> ( a, b, c ) -> ( x, b, c )"
          },
          {
            "name": "mapSnd",
            "comment": " ",
            "type": "(b -> x) -> ( a, b, c ) -> ( a, x, c )"
          },
          {
            "name": "mapTrd",
            "comment": " ",
            "type": "(c -> x) -> ( a, b, c ) -> ( a, b, x )"
          },
          {
            "name": "snd",
            "comment": " ",
            "type": "( a, b, c ) -> b"
          },
          {
            "name": "swirll",
            "comment": " ",
            "type": "( a, b, c ) -> ( c, a, b )"
          },
          {
            "name": "swirlr",
            "comment": " ",
            "type": "( a, b, c ) -> ( b, c, a )"
          },
          {
            "name": "tail",
            "comment": " ",
            "type": "( a, b, c ) -> ( b, c )"
          },
          {
            "name": "toList",
            "comment": " ",
            "type": "( a, a, a ) -> List a"
          },
          {
            "name": "trd",
            "comment": " ",
            "type": "( a, b, c ) -> c"
          }
        ],
        "generated-with-elm-version": "0.17.0"
      }
    ]
  },
  {
    "name": "NoRedInk/elm-decode-pipeline",
    "version": "1.1.2",
    "docs": [
      {
        "name": "Json.Decode.Pipeline",
        "comment": " ## Design Principles\n\n* Introduce functions that work well with the [`(|>)`](http://package.elm-lang.org/packages/elm-lang/core/3.0.0/Basics#|>) operator\n* Don't introduce any custom infix operators\n* Don't introduce any functions that are intended to be called using backticks\n\n@docs required, requiredAt, optional, optionalAt, hardcoded, custom, resolveResult, decode\n",
        "aliases": [],
        "types": [],
        "values": [
          {
            "name": "custom",
            "comment": " Run the given decoder and feed its result into the pipeline at this point.\n\nConsider this example.\n\n    import Json.Decode exposing (int, string, at, Decoder)\n    import Json.Decode.Pipeline exposing (decode, required, custom)\n\n\n    type alias User =\n      { id : Int\n      , name : String\n      , email : String\n      }\n\n\n    userDecoder : Decoder User\n    userDecoder =\n      decode User\n        |> required \"id\" int\n        |> custom (at [ \"profile\", \"name\" ])\n        |> required \"email\" string\n\n\n    result : Result String User\n    result =\n      Json.Decode.decodeString\n        userDecoder\n        \"\"\"\n          {\n            \"id\": 123,\n            \"email\": \"sam@example.com\",\n            \"profile\": {\"name\": \"Sam\"}\n          }\n        \"\"\"\n    -- Ok { id = 123, name = \"Sam\", email = \"sam@example.com\" }\n",
            "type": "Json.Decode.Decoder a -> Json.Decode.Decoder (a -> b) -> Json.Decode.Decoder b"
          },
          {
            "name": "decode",
            "comment": " Begin a decoding pipeline. This is a synonym for [Json.Decode.succeed](http://package.elm-lang.org/packages/elm-lang/core/3.0.0/Json-Decode#succeed),\nintended to make things read more clearly.\n\n    import Json.Decode exposing (int, string, float, Decoder)\n    import Json.Decode.Pipeline exposing (decode, required, optional)\n\n\n    type alias User =\n      { id : Int\n      , email : String\n      , name : String\n      }\n\n\n    userDecoder : Decoder User\n    userDecoder =\n      decode User\n        |> required \"id\" int\n        |> required \"email\" string\n        |> optional \"name\" string \"\"\n",
            "type": "a -> Json.Decode.Decoder a"
          },
          {
            "name": "hardcoded",
            "comment": " Rather than decoding anything, use a fixed value for the next step in the\npipeline. `harcoded` does not look at the JSON at all.\n\n    import Json.Decode exposing (int, string, Decoder)\n    import Json.Decode.Pipeline exposing (decode, required)\n\n\n    type alias User =\n      { id : Int\n      , email : String\n      , followers : Int\n      }\n\n\n    userDecoder : Decoder User\n    userDecoder =\n      decode User\n        |> required \"id\" int\n        |> required \"email\" string\n        |> hardcoded 0\n\n\n    result : Result String User\n    result =\n      Json.Decode.decodeString\n        userDecoder\n        \"\"\"\n          {\"id\": 123, \"email\": \"sam@example.com\"}\n        \"\"\"\n    -- Ok { id = 123, email = \"sam@example.com\", followers = 0 }\n",
            "type": "a -> Json.Decode.Decoder (a -> b) -> Json.Decode.Decoder b"
          },
          {
            "name": "optional",
            "comment": " Decode a field that may or may not be present. If the field is present,\nuse the specified decoder on it. If the field is not present, successfully\ndecode to the given fallback value.\n\n    import Json.Decode exposing (int, string, Decoder)\n    import Json.Decode.Pipeline exposing (decode, required, optional)\n\n\n    type alias User =\n      { id : Int\n      , name : String\n      , email : String\n      }\n\n\n    userDecoder : Decoder User\n    userDecoder =\n      decode User\n        |> required \"id\" int\n        |> optional \"name\" string \"blah\"\n        |> required \"email\" string\n\n\n    result : Result String User\n    result =\n      Json.Decode.decodeString\n        userDecoder\n        \"\"\"\n          {\"id\": 123, \"email\": \"sam@example.com\" }\n        \"\"\"\n    -- Ok { id = 123, name = \"blah\", email = \"sam@example.com\" }\n\n",
            "type": "String -> Json.Decode.Decoder a -> a -> Json.Decode.Decoder (a -> b) -> Json.Decode.Decoder b"
          },
          {
            "name": "optionalAt",
            "comment": " Decode an optional nested field.\n",
            "type": "List String -> Json.Decode.Decoder a -> a -> Json.Decode.Decoder (a -> b) -> Json.Decode.Decoder b"
          },
          {
            "name": "required",
            "comment": " Decode a required field.\n\n    import Json.Decode exposing (int, string, Decoder)\n    import Json.Decode.Pipeline exposing (decode, required)\n\n\n    type alias User =\n      { id : Int\n      , name : String\n      , email : String\n      }\n\n\n    userDecoder : Decoder User\n    userDecoder =\n      decode User\n        |> required \"id\" int\n        |> required \"name\" string\n        |> required \"email\" string\n\n\n    result : Result String User\n    result =\n      Json.Decode.decodeString\n        userDecoder\n        \"\"\"\n          {\"id\": 123, \"email\": \"sam@example.com\", \"name\": \"Sam\"}\n        \"\"\"\n    -- Ok { id = 123, name = \"Sam\", email = \"sam@example.com\" }\n",
            "type": "String -> Json.Decode.Decoder a -> Json.Decode.Decoder (a -> b) -> Json.Decode.Decoder b"
          },
          {
            "name": "requiredAt",
            "comment": " Decode a required nested field.\n",
            "type": "List String -> Json.Decode.Decoder a -> Json.Decode.Decoder (a -> b) -> Json.Decode.Decoder b"
          },
          {
            "name": "resolveResult",
            "comment": " Convert a `Decoder (Result x a)` into a `Decoder a`. Useful when you want\nto perform some custom processing just before completing the decoding operation.\n\n    import Json.Decode exposing (int, string, float, Decoder)\n    import Json.Decode.Pipeline exposing\n      (decode, required, resolveResult)\n\n\n    type alias User =\n      { id : Int\n      , email : String\n      }\n\n\n    userDecoder : Decoder User\n    userDecoder =\n      let\n        -- asResult gets run *after* all the\n        -- (|> required ...) steps are done.\n        asResult Int -> String -> Int -> Result String User\n        asResult id email version =\n          if version > 2 then\n            Ok (User id email)\n          else\n            Err \"This JSON is from a deprecated source. Please upgrade!\"\n      in\n        decode asResult\n          |> required \"id\" int\n          |> required \"email\" string\n          |> required \"version\" int -- version is part of asResult,\n          |> resolveResult          -- but it is not a part of User\n\n\n    result : Result String User\n    result =\n      Json.Decode.decodeString\n        userDecoder\n        \"\"\"\n          {\"id\": 123, \"email\": \"sam@example.com\", \"version\": 1}\n        \"\"\"\n    -- Err \"This JSON is from a deprecated source. Please upgrade!\"\n",
            "type": "Json.Decode.Decoder (Result.Result String a) -> Json.Decode.Decoder a"
          }
        ],
        "generated-with-elm-version": "0.17.0"
      }
    ]
  },
  {
    "name": "NoRedInk/elm-phoenix",
    "version": "1.0.0",
    "docs": [
      {
        "name": "Phoenix.Channel.Helpers",
        "comment": " Helpers\n\nConvert your response type from a string to a message\n@docs assignResponseType\n\n",
        "aliases": [],
        "types": [],
        "values": [
          {
            "name": "assignResponseType",
            "comment": " Converts a string into a Msg\n",
            "type": "String -> Phoenix.Channel.Update.Msg"
          }
        ],
        "generated-with-elm-version": "0.17.0"
      },
      {
        "name": "Phoenix.Channel.Update",
        "comment": "\n\nThe possible messages from the server\n@docs Msg\n\nThe update function for dealing with that\n@docs update\n",
        "aliases": [],
        "types": [
          {
            "name": "Msg",
            "comment": "\n  - SuccessfulResponse is only triggered when \"ok\" is the status\n  - ErrorResponse is everything else\n",
            "args": [],
            "cases": [
              [
                "SuccessfulResponse",
                [
                  "Phoenix.Channel.Model.SocketMessage"
                ]
              ],
              [
                "ErrorResponse",
                [
                  "String"
                ]
              ],
              [
                "SendMessage",
                [
                  "Phoenix.Channel.Model.MessageToSend"
                ]
              ]
            ]
          }
        ],
        "values": [
          {
            "name": "update",
            "comment": " Take a msg from a channel, and update the model based on the msg recieved\n",
            "type": "Phoenix.Channel.Update.Msg -> Phoenix.Channel.Model.Model a -> ( Phoenix.Channel.Model.Model a , Platform.Cmd.Cmd Phoenix.Channel.Update.Msg )"
          }
        ],
        "generated-with-elm-version": "0.17.0"
      },
      {
        "name": "Phoenix.Channel.Model",
        "comment": " Types used for representing things that come from a phoenix channel\n\nOur model used in our Program components\n@docs Model\n\nDealing with server responses\n@docs decodeSocketMessage\n@docs SocketMessage, ResponsePayload, Response\n\nSending stuff to the server\n@docs encodeMessageToSend\n@docs MessageToSend\n",
        "aliases": [
          {
            "name": "MessageToSend",
            "comment": " Like a socket message, but comes with a pre-encoded payload\n",
            "args": [],
            "type": "{ topic : String , ref : Int , payload : Json.Encode.Value , event : String }"
          },
          {
            "name": "Model",
            "comment": " We demand that any model must store the socket events, the current refNumber, and\nthe state of connection\n",
            "args": [
              "a"
            ],
            "type": "{ a | socketEvents : List Phoenix.Channel.Model.SocketMessage, refNumber : Int, connected : Bool, socketUrl : String }"
          },
          {
            "name": "Response",
            "comment": " A response from the server\n",
            "args": [],
            "type": "{ reason : String }"
          },
          {
            "name": "ResponsePayload",
            "comment": " The status of the response paired with the response itself\n",
            "args": [],
            "type": "{ status : String, response : Phoenix.Channel.Model.Response }"
          },
          {
            "name": "SocketMessage",
            "comment": " Each socket response has the topic (room) as a string, along with a ref count\n    the event to trigger, and the payload of what the server actually sent\n",
            "args": [],
            "type": "{ topic : String , ref : Int , payload : Phoenix.Channel.Model.ResponsePayload , event : String }"
          }
        ],
        "types": [],
        "values": [
          {
            "name": "decodeSocketMessage",
            "comment": " Decode a socket response.\n",
            "type": "Json.Decode.Decoder Phoenix.Channel.Model.SocketMessage"
          },
          {
            "name": "encodeMessageToSend",
            "comment": " Encode a message to send\n",
            "type": "Phoenix.Channel.Model.MessageToSend -> Json.Encode.Value"
          }
        ],
        "generated-with-elm-version": "0.17.0"
      }
    ]
  },
  {
    "name": "NoRedInk/elm-task-extra",
    "version": "2.0.0",
    "docs": [
      {
        "name": "Task.Extra",
        "comment": " Contains a list of convenient functions that cover common use cases\nfor tasks.\n\n# Chaining Tasks\n@docs optional, parallel\n\n# Delay a task\n@docs delay\n\n# Looping forever\n@docs loop\n\n# Commands\n@docs performFailproof\n",
        "aliases": [],
        "types": [],
        "values": [
          {
            "name": "delay",
            "comment": " Delay a task by a given amount of time in milliseconds.\n",
            "type": "Time.Time -> Task.Task error value -> Task.Task error value"
          },
          {
            "name": "loop",
            "comment": " Runs a task repeatedly every given milliseconds.\n\n    loop 1000 myTask -- Runs `myTask` every second\n",
            "type": "Time.Time -> Task.Task error value -> Task.Task error ()"
          },
          {
            "name": "optional",
            "comment": " Similar to `Task.sequence`.\nThe difference with `Task.sequence` is that it doesn't return an `error` if\nany individual task fails. If an error is encountered, then this function will\nmarch on and perform the next task ignoring the error.\n",
            "type": "List (Task.Task x value) -> Task.Task y (List value)"
          },
          {
            "name": "parallel",
            "comment": " Analogous to `Task.sequence`.\nSchedule a list of tasks to be performed in parallel as opposed to in series\nas is the case with `Task.sequence`.\n\n*Note that there is no guarantee that the tasks will be performed or complete\nin the order you have stated. This is why you may use the returned `Process.Id`\nfor re-ordering or consider integrating a sorting mechanism within your program.*\n",
            "type": "List (Task.Task error value) -> Task.Task error (List Process.Id)"
          },
          {
            "name": "performFailproof",
            "comment": " Command the runtime system to perform a task that is guaranteed to\nnot fail. The most important argument is the\n[`Task`](http://package.elm-lang.org/packages/elm-lang/core/latest/Task#Task)\nwhich describes what you want to happen. But you also need to provide\na function to tag the success outcome, so as to have a message to feed\nback into your application. Unlike with the standard\n[`perform`](http://package.elm-lang.org/packages/elm-lang/core/latest/Task#perform),\nyou need not provide a function to tag a failing outcome, because the\n[`Never`](http://package.elm-lang.org/packages/elm-lang/core/latest/Basics#Never)\nin the type `Task Never a` expresses that no possibly failing task is\nallowed in that place anyway.\n\nA typical use of the function is `Date.now |> performFailproof CurrentDate`.\n",
            "type": "(a -> msg) -> Task.Task Basics.Never a -> Platform.Cmd.Cmd msg"
          }
        ],
        "generated-with-elm-version": "0.17.0"
      }
    ]
  }
]
